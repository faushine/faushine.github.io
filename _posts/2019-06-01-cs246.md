---
layout: post
title: "Class Notes of CS246"
date:   2019-06-08
author: Faushine
tags: 
- Notes
---

# Quotes in bash (see 'man bash')

- backticks, single back quotes->executes command

    ```bash
    ls -al use $(ls -al) instead
    ```

- double quotes '' not ""

    ```bash
    $ -usually port of retrieving var.data
    ' -single quotes
    \ -backsbash, usually used to force shell to treat characters
    *, @, # -are special, will see shortly  
    ```

- single quote(') 
  &rarr; no substitution at all
  
  &rarr; cannot be nested eg |||

- egrep - extended global regular expression print 
  &rarr; line-by-line comparisons an input and print

- regular expression and characters plus meta/special characters that control what matches

    | &rarr; alternations i.e egrep dog|cat myfile.txt
    () &rarr; used to group string
    \* &rarr; 0 or more of preceding character eg ba* &rarr; b, ba, baaa, or xb, xby
    \+ &rarr; 1 or more ....
    [] &rarr; select *one* of eg. [abcd] &rarr; [a-z0-9A-Z]
    &rarr; [^a-d] not abcd
    ^xgg &rarr; line must start with xgg
    xgg$ &rarr; line must end with xgg
    ^xgg$ &rarr; entire line must be xgg

### Examples:

Find all occurrences of 'cs246' in f.txt

```bash
egrep cs246 f.txt
```

Find all occurrences of either 'cs246' of 'cs247'

``` bash
egrep cs246|cs247 < f.txt
or 
egrep cs24[67] f.txt
```

Find all lines whose length is even  eg.0 character or 2,4 etc

```bash
egrep "^(..)*$" f.txt
```

All filenames in current directory, which contain only 1 'a' (but can have other characters)

```bash
ls | egrep "^[^a]*a[^a]*$"
```

Find all 5-letter words that start with 'e'

```bash
egrep "^e.....$" < /usr/share/dict/words
```

- globbing patterns is not regular expression 

    ```bash
    a?=>0 or 1 a 
    ? [x] man 7 glob
    * [!x]

    ls -l
    - rwx rwx rwx
    owner(user) group other(no r or w there)
    chmod: change permissions
    -R recursive change

    who +(-) what 
    ugo      rwx
    eg: chmod -R o-rwx
    ```

# shell scripts

~/cs246/1195/lectures/shell/scripts

## what is shell scripts?

the file contains a sequence of commands, executed as it was a program

## How does the operating system know where to look for your program

it looks in the environment variable, PATH
eg, echo $PATH
can use 'env'

bin-binary
env-environment configuration

```bash
\#!/bin/bash
```

```bash
date
whoim
pwd
```

- comments start with a '#'
    1st line is called 'shebang' line; must start with #!

    followed by shell to use then options eg -x <-verbose mode

- file suffix is , by convention, .sh or .bash; but ,not required
  
- need to tell shell where the 'program' is 
    &rarr; current directory -> './'

    &rarr; make sure you add execute permission to file via : chmod u+x basic

- variable name are strings; so are the values
  
- no space on either side of equal sign; variable on left-hand side may not have a $ infront eg. x=1
  
- should surround variable name with {3 when used ie. value extracted eg:

    ```bash
    echo xy
    echo ${x}y
    ```

- variables can be global to the script
- use appropriate quotation marks 

    ```bash
    $Q <- name of the script
    $1 $2 .. <- command line argument
    $# <- number of command line argument

    $? - returen value of conmmand just executed
    $* - concentrate all command line arguments into a single string( by default, separated by a space)
    ```

### eg: good password
/dev/null: if redirect output here, it is discarded

```bash
if[...]; then
elif[...]; then
.
.
.
else
fi
```

## Function

```bash
[function] name ()<-nothing in there
{
    #body of function
    access call parameters cia $i, etc
}
called via: name list of parameters
N.B.: "exit" is a hard-kill i.e. terminates executtion
```

## Loops

```bash
#!/bin/bash
x=1
while [ ${x} -le 1 ]; do
    echo $x
    x=$((x+1)) -> how we do arithmetic
done

for variable in list; do
    #stuff
done
```

```bash
name%c => substring c
```

Paydays at UW far non-union staff is last Friday of the month

```bash
(1) cal
(2) | awk  '{print $6}'
(3) | egrep "[0-9]"
(4) | tail -1
```

# SE & Testing

- correctness implies meeting (user) specification
a good test case is one that expose flaws in the code

- can use formal proofs of correctness, but this is hard

- testing is  hard: no unfailing algorithm to always find error, unconscious bias to protect code

- this is why the tester shouldn't also be the developer

- testing is an ongoing process; it starts before you code, goes on while coding , and continues in maintenance

- testing is a skill; experience helps

- testing is not debugging, you use testing to uncover bugs and check to see if you fixed then.

## Two main factors:

(1) human: look over code for flaws; walk-throughs or code inspections

(2) machine: run program on selected input, check against specification

    &rarr; a few, well chosen test cases are better than having many, poorly-chosen test cases.

    &rarr; can't test everything since #cases(usually) exponential

we generally divide cases into 3 types of testing

1. black box: don't know details of implementation, use psec, to guide test cases
2. white box: know code details; exercise all paths
   
    &rarr; focus most heavily on where bulk of work is done

3. grey box: know some details

    start with black box test cases, supplement with cases not covered that come from white/grey box testing

- divide test cases into 'equivalence classes'; only need a few from eacj
  
- look at 'edge cases' - boundaries eg.month is 1-12, so 1, 12, 13
  
- 'corner cases' are combinations of edge cases eg. Feb.29 or Feb.28-leap year?
  
- extence cases (but don't get carried away)
  
    eg. very large vs small data sets, or image

- this is where intuition matters-get a feeling for where common errors happen

## performance testing

is the program efficient enough?
eg. speed, memory, etc

- regression testing-makes sure new changes to program doesn't break old functionality

- never remove test cases, always add

    relies on having test suites (collection of test cases) test scripts to automate

Q: read a file for input

exist?

empty?

responds on context

readable?

Q: sorting?

large vs small

ascending, descending, random

Q: ordered linked list?

empty or not?

beginning, middle or end as insertion points

duplicates

hello world

```bash
#include<stdio.h>   
int main(){
    printf("hello world]\n");
    return 0;
}

#include<iostream>
using namespace std;
int main(){
    std::cout<<"hello"<<"world"<<std::endl;
    return 0;
}
```

- must compile before can run
  
```bash
g++ hellp.cc 
# => a.out; run ./a.out
g++ -o hello hello.cc
g++ => g++-14 =? g++ -std=c++14
-g saves symbol table into needed by debugger
-wall
-wextrg
-werror
-wpedantic
```

see man gcc

- in c++, must to read before test for eof()(&rarr;try if end of file) or fail()(&rarr;eof or error)

    &rarr; good(): ! fail() && bad()

    &rarr; bad(): if true, stream is corrupted and all bets are off

- note that cin can be executed into a boolean value if (!cin) break; !cin is operator! 

    {return fail();}


# I/O

~/cs246/1195/lecture/c++/Q2-io

readInts.cc

- #include <iostream> to access cin/cout/cerr
(actual c++ objects; equivalent to stdin, stdout, stderr respectively)

    &rarr; part of "std" namespace, so either need "std:" in front of cin, etc, or need "using namespace std;"

- endl: combination of newline + request to flush buffer
  
- c++ over-loads bit-shift operators for I/O

    ```bash
    std::istream operator <<(istream&, int&)
    int i,j; char c;
    cin >>i>>c>>j;
    ```

- must try to read before check for success

now, if have a non-int "throw" away offending character(s) and keep going

&rarr; use cin.ignore() to throw away 1 char and must reset state bits via cin.clear()

conversionChar.cc

- must include \<iomanip>
- format made (hex, octal, dex) remain until set to something else
- setw(3) ->set width i.e. pads values(default in space)

## C - style strings(char*, char[])

- must explicitly manage memory i.e. reallocate + copy if need larger
- must delimit with '\'; easy error if forget or in wrong place

## C++ - style strings

```bash
#include<string>
std::string s = "hello"
```

- overloaded operator for string concatenation?
getline(cin,s)

sstream

istreamstring

ostreamstring

mostly to build up strings for a output.

# Default parameters

- lets you avoid code repetition by using 'overloading'.
- C doesn't allow overloading since all function names must be unique, but C++ allows this:
  
  ```c++
  void print(int c); 
  void print(char c); 
  void print(double c);
  ```

- but in order to for the compiler to know which one you meant, the functions must differ in number and/or types the parameters.
  
  ```c++
  print('a'); 
  print(5);
  ```

- note that it isn't enough to just have different them return types as a way to distinguish between them
- when have default arguments, they must be the last arguments in the list, no gaps.
- c++ allows "structs" like c, but embed functions(called 'methods') within the struct.

# Constants

```c++
const int MAX_SIZE = 4026
```

- compiler will let you know if try to modify constants

- can declare return type, parameters and/or methods as "const"

    ```c++
    struct Node{
        void printList() const{
            Node *p = next;
            while(p!=nullptr){
                cout<<p->next<<endl;
                p = p->next;
            }
        }
    }
    ```

# Parameter Passing

- call-by-value: parameters and/or return values are copied on the runtime stack

    ```c++
    int x = 1;
    foo(x);
    cout<< x;

    void foo(int i){
        i+=1;
    }
    ```

&rarr; value won't be changed since changes are discarded

&rarr; if size of int (or less), or making copy anyways, should't use!

- could use pointers, but then have to deference

    ```c++
    int x = 1;
    foo(x);
    cout<< x << endl;
    void foo(int *i){
        *i+=1;
    }
    ```
  
    ```c++
    int x = 1;
    foo(x);
    coit << x;
    void foo(int &(i)){
        i+=1;
    }
    ```

# Reference

- things you cannot do with references: eg int i; int $reg=i; (lvalue)

  1. cannot bind "ref" to another memory location

      lvalue: whatever (usually) has a memory location; if it's not an lvalue, it's a rvalue

  2. cannot bind it to an rvalue eg.

      ```c++
      int &ref=3;
      int &ref=xyz;
      //however, this is correct. l has a memory address
      int &ref = l; //ref是别名
      ```

- can have a reference to a pointer, not a pointer to a reference

    ```c++
    int *ptr;
    int *&ref = ptr; //leagal
    int &*ref; //won't complie
    int &&ref; // not a reference to a reference means something else in c++11
    ```

- passing by reference avoids copying done by pass-by values; but, function anc now change it
  
  &rarr; declare it as constant eg. 

  ```c++
  void foo(const & int i){
      //
  }  
  ```

  return by value, pointer, or reference

- in some circumstances, no choice eg. istream operator>> has to return stream by reference in order to be able to cascade operators eg. cin>>i>>y

    ```c++
    // overloading
    std::ostream & operator<<(std::ostream &out const Node &n){
        out << n.value << endl;
        return out;
    }

    Node n{3, null};
    cout << n;
    ```

    ```c++
    Node getNode(){
        Node n{3, nullptr};
        return n;
        // makes copy of local Node "n"(lvalue) on runtime stack(rvalue)
    }
    //...
    Node m = getNode(); // rvalue copied into m
    ```

- but smart compilers, or c++11; can optimize this and/or use "move"

    semantics &rarr; actually move efficient than might expect

    ```c++
    Node * getNode(){
        Node n;
        return &n;
    }
    //...
    Node * ptr = getNode();
    //has address of variable that no longer exists

    Node * getNode(){
        Node n;
    return new Node{3, nullptr};
    //now need to remember to do a delete
    }
    //...
    Node * ptr = getNode();

    Node & getNode(){
        Node n;
    return *(new Node{3, nullptr}); 
    //now need to remember to do a delete
    }
    //...
    Node & ptr = getNode();
    // delete &ptr;
    ```

## Dynamic memory allocation

**C**: use malloc, calloc, realloc, free

&rarr; use (void*), so no type safe and easier to make mistakes

**C++**: uses new, delete, nullptr

 ```c++
    int * ptr = nullptr;
    ptr = new int {-13};
    delete ptr;
```

```c++
    int ** arr;
    arr = new int * [max];
    for (int i=0; i< max; ++i){
        arr[i] = new int [dimx];
        //...
    }
    //...
    for (int i = 0; i < max; i++){
        delete [] arr[i];
        delete [] arr;
    }
 ```
    

- program crashes if try to free same memory address more than onec.

## operator overloading

see operators/grades.cc,vectors.cc

## preprocessor 

- first compilation phase (see g++ -E)

- translates "directives" : #\<keywords>
  eg. #include\<iostream>

    ```c++
    #define MAX 10; //use const int MAX=10; instead since not type safe

    MAXabc = MAXy;
    cout << "MAXxxx";

    #define SECURITY_LEVEL 1

    #if SECURITY_LEVEL == 1

    #elif SECURITY_LEVEL == 2

    #elif

    #endif
    ```

# Separate compilation

Recall: 
- declaration: specifies existence eg.type
  
  ```c++
  struct Node;
  void print(std::ostream &out, const Node &n);
  extern int MAX;
  ```

- definition: variables(and functions) have space allocated; fll type info is known
  
  ```c++
  eg. struct nODE {
      int value;
      Node *next;
  }
  ```

```c++
void print(std::ostream &out, const node &n){
    out<<'('<< n.value << "," << hex << n.next<<')';
}
int MAX=10;
```

## module: collection of data, types, functions

- ideally serves one main purpose (Single Responsibility Principle)

- a module is made up of:

    - interfaces (*.h, *.hpp) contain type definitions (maybe declarations, but eventually need defn) global variable and function declarations

    - implementations(*.cpp, *.cc) contains function definitions and global variable definitions

- by using "separate compilation, only recompile what you have to and "link" the pieces

- separate compilation implicates using the "-c" flag when compiling an implementation file (.cc) to create the corresponding object file (.o) and then linking all .o files together to create the executable.

    &rarr; recompile only what changed, then relink everything.

- in order to automate this, need to find a way to figure out dependencies and what changed

## make

- by default, make looks for a file called "makefile" or "Makefile"

- the file lists all dependencies, and what command (or commands) to run

    ```bash
    <target> : <dependencies>
        \t command 1
        \t command 2
    clean:
        rm *.o a.out

    make clean
    ```

- vec-example 2

    CXX &larr; makes's variable to define c++ compiler

    CXXFLAGS &larr; makes var for compiler options

    make knows how to create a .o file from a .cc without you specifying, &rarr; but still listing dependencies

    stop comp

- can't have multiple definitions (see example 3)

- use "include guards" to prevent this

    ```c++
    #ifndef <randomname>
    #define <randomname>

    ...

    #endif

    #ifndef VEC_H
    #define VEC_H

    ...

    #endif
    ```

## Separate compilation do's and don'ts

1) always put include guards in your header files
   
2) Never put "using namespace std;" in your headerfiles (use "std::istream",etc)
   
3) Never compile a header file
   
4) Never include implementation files

# Classes

```c++
#ifndef STUDENT_H

#define student.h

struct Student{
    int assns, midterm, final;
    int grade();
}
#endif
```

```c++
#include "student.h"

int student::grade(){
    return (assns*0.4 + midterm*0.2 + final*0.4)
}
```

```c++
//main.cc
#include "student.h"

int main(){
    Student s{75,80,77};
};
int final grade = s.grade();
```

- C++ has a "this" keyword, which is a pointer and helps the object refer to itself when needed.

    ```c++
    struct student{
        ...
        void student(){
            this->mt = mt;
        }
        int grade(){
            return (this.assns);
        }
    }
    ```

## Initializing objects

can initialize an object using either = or ()

```c++
Student s(24,24,24);
Student t = s; // t has same value as s
Student r = Student {54,45,45};
```

- but, there are complicated rules as to where and when they can't be used, so c++11 introduced "uniform initialization"

- always use {} in this course

> Aside: see "zero initialization" for what c++11 and up will set to 0(or zero-equipment)

- use "**constructors**" (**ctor**) to ensure objects are initialize "properly"

    ```c++
    struct Student{
        ...
        Student(int a=0, int m = 0, int f = 0);
    };
    student::Student(int a, int m, int f){
        assns = a;
        mt = m;
        final = f;
    }
    ```

- a "default ctor" is a ctor with no parameters
    - the compiler gives you one, which follows basic initialization rules, until you write a ctor.
    - see, "zero initialization"
    - objects must have a default ctor, else error
    ```c++
    struct Class{
        Student arr[180];
        ...
    };
    ```

- what if want a constant?

    ```c++
    Struct Student{
        const int MAX_GRADE = 100;
        ...
    }
    ```

Q: what if want student to have a different, constant id# for each student object?

A: There are 3 steps when an object is created:

1. allocate space
2. initialize fields
3. ctor body runs

- initializing them in the ctor body is too late 

    &rarr; needs to be done as part of step 2
    
    &rarr; introduce idea of Memory Initialization Lists(MIL)

    - special syntax on ctor definition

    ```c++
    Student(const int id, int a = 0, int m = 0, int f = 0):id{id}, assns{a}, int {m}, final{f}{
        /* nothing left to do */
    };
    ```

- must use MIL if object has data field that are objects that don't have default ctors
    
    &rarr; use MIL as much as possible since can prevent duplicate work. i.e.initialize in both MIL and in ctor body.

    ```
    struct Student{
        Grade a,m,f; // Grade(int i = 0)
        ...
        Student(Grade a, Grade m, Grade f): 
        this->a=a; this->m=m; this->f=f; 
    }
    ```


